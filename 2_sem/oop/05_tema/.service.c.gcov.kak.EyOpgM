        -:    0:Source:service.c
        -:    1:#include "service.h"
        -:    2:
        6:    3:Service* create_service(Lista* repository)
        -:    4:{
        6:    5:	Service* srv = (Service*)malloc(sizeof(Service));
        6:    6:	if (srv != NULL)
        -:    7:	{
        6:    8:		srv->repository = repository;
        6:    9:		srv->undo_stack = create_vec(
        -:   10:			sizeof(Vec*),
        -:   11:			copy_list_generic,
        -:   12:			destroy_list_generic
        -:   13:		);
        -:   14:	}
        6:   15:	return srv;
        -:   16:}
        6:   17:void destroy_service(Service* srv)
        -:   18:{
        6:   19:	destroy_list(srv->repository);
        6:   20:	destroy_vec(srv->undo_stack);
        6:   21:	free(srv);
        6:   22:}
        -:   23:
       17:   24:int addEntity(Service* srv, char* nume, char* producator, float cantitate)
        -:   25:{
       17:   26:	Materie* m = creare_materie(nume, producator, cantitate);
       17:   27:	if (validare(m) == -2)
        -:   28:	{
        1:   29:		destroy_entity(m);
        1:   30:		return -2;
        -:   31:	}
       16:   32:	vec_push(srv->undo_stack, &srv->repository);
       16:   33:	addRepo(srv->repository,m);
       16:   34:	destroy_entity(m);
       16:   35:	return 0;
        -:   36:}
        3:   37:int modifyEntity(Service* srv, char* nume, char* producator, float cantitate)
        -:   38:{
        3:   39:	Materie* m = creare_materie(nume, producator, cantitate);
        3:   40:	if (validare(m) == -2)
        -:   41:	{
        1:   42:		destroy_entity(m);
        1:   43:		return -2;
        -:   44:	}
        -:   45:	
        -:   46:	Lista* l;
        2:   47:	copy_list(&l, &srv->repository);
        2:   48:	if (modifyRepo(srv->repository, m) == -1)
        -:   49:	{
        1:   50:		destroy_entity(m);
        1:   51:		destroy_list(l);
        1:   52:		return -1;//inexistent
        -:   53:	}
        1:   54:	vec_push(srv->undo_stack, &l);
        1:   55:	destroy_list(l);
        1:   56:	destroy_entity(m);
        1:   57:	return 0;//ok
        -:   58:}
        2:   59:int deleteEntity(Service* srv, char* nume)
        -:   60:{
        -:   61:	Lista* l;
        2:   62:	copy_list(&l, &srv->repository);
        2:   63:	int rez = deleteRepo(srv->repository, nume);
        2:   64:	if (rez != 0) {
        1:   65:		destroy_list(l);
        1:   66:		return rez;
        -:   67:	}
        1:   68:	vec_push(srv->undo_stack, &l);
        1:   69:	destroy_list(l);
        1:   70:	return 0;
        -:   71:}
        -:   72:
        1:   73:Lista* criterialist(Service* srv, float cantitate)
        -:   74:{
        1:   75:	Lista* rez = get_filtered(srv->repository,cantitate);
        1:   76:	return rez;
        -:   77:}
        1:   78:Lista* criterialist_above(Service* srv, float cantitate)
        -:   79:{
        1:   80:	Lista* rez = get_filtered_above(srv->repository,cantitate);
        1:   81:	return rez;
        -:   82:}
        1:   83:Vec* sortedEntities(Service* srv)
        -:   84:{
        1:   85:	Vec* rez = get_all(srv->repository);
        -:   86:	Materie *aux;
        4:   87:	for (int i = 0;i < rez->lg - 1;i++)
        -:   88:	{
        -:   89:		// Materie* temp = get(rez, i);
        -:   90:		Materie* temp;
        3:   91:		vec_get(rez, (void*) &temp, i);
        -:   92:		
        9:   93:		for (int j = i + 1;j < rez->lg;j++)
        -:   94:		{
        -:   95:			// Materie* temp2 = get(rez, j);
        -:   96:			Materie* temp2;
        6:   97:			vec_get(rez, (void*) &temp2, j);
        6:   98:			if (temp->cantitate > temp2->cantitate)
        -:   99:			{
        2:  100:				vec_set(rez, i, (void*) &temp2);
        2:  101:				vec_set(rez, j, (void*) &temp);
        2:  102:				aux = temp;
        2:  103:				temp = temp2;
        2:  104:				temp2 = aux;
        -:  105:				// aux = rez->elems[i];
        -:  106:				// rez->elems[i] = rez->elems[j];
        -:  107:				// rez->elems[j] = aux;
        -:  108:			}
        6:  109:			destroy_entity(temp2);
        -:  110:		}
        3:  111:		destroy_entity(temp);
        -:  112:	}
        1:  113:	return rez;
        -:  114:}
        -:  115:
    #####:  116:int undo(Service* srv) {
        -:  117:	/*
        -:  118:	 * Reface ultima operatie.
        -:  119:	 * input : srv - service-ul in care se va reface ultima operatie
        -:  120:	 * output: 0, daca operatia a fost refacuta cu succes, si -6 altfel
        -:  121:	 */
    #####:  122:	if (srv->undo_stack->lg <= 0) return -6;
        -:  123:	Lista* repo;
    #####:  124:	vec_get(srv->undo_stack, &repo, srv->undo_stack->lg-1);
    #####:  125:	vec_erase(srv->undo_stack, srv->undo_stack->lg-1);
    #####:  126:	destroy_list(srv->repository);
    #####:  127:	srv->repository = repo;
    #####:  128:	return 0;
        -:  129:}
